1、问题：我们相对一系列元素所有可能的组合或排列进行迭代
2、方法：itertools.permutations()，他接受一个元素集合，将其中所有的元素重排列为所有可能的情况，并以元组序列的形式返回
>>> from itertools import permutations
>>> a = [1,2,3,4]
>>> for p in permutations(a):
...     print(p)
... 
(1, 2, 3, 4)
(1, 2, 4, 3)
(1, 3, 2, 4)
(1, 3, 4, 2)
(1, 4, 2, 3)
(1, 4, 3, 2)
(2, 1, 3, 4)
(2, 1, 4, 3)
(2, 3, 1, 4)
(2, 3, 4, 1)
(2, 4, 1, 3)
(2, 4, 3, 1)
(3, 1, 2, 4)
(3, 1, 4, 2)
(3, 2, 1, 4)
(3, 2, 4, 1)
(3, 4, 1, 2)
(3, 4, 2, 1)
(4, 1, 2, 3)
(4, 1, 3, 2)
(4, 2, 1, 3)
(4, 2, 3, 1)
(4, 3, 1, 2)
(4, 3, 2, 1)
如果想得到较短长度的所有全排列，可以提供一个可选的长度参数
>>> for p in permutations(a, 2):
...     print(p)
... 
(1, 2)
(1, 3)
(1, 4)
(2, 1)
(2, 3)
(2, 4)
(3, 1)
(3, 2)
(3, 4)
(4, 1)
(4, 2)
(4, 3)
itertools.combinations()，可产生输入序列中所有元素的全部组合形式
>>> from itertools import combinations
>>> for p in combinations(a, 4):
...     print(p)
... 
(1, 2, 3, 4)
>>> for p in combinations(a, 3):
...     print(p)
... 
(1, 2, 3)
(1, 2, 4)
(1, 3, 4)
(2, 3, 4)
对于combinations来说，元素之间的世纪顺序是不予考虑的。也就是说，组合(a, b)和(b, a)是相同的。当产生组合时，已经选择过的元素将从可能的候选元素中移除掉
itertools.combinations_with_replacement()函数解放这一限制
>>> from itertools import combinations_with_replacement
>>> for p in combinations_with_replacement(a, 4):
...     print(p)
... 
(1, 1, 1, 1)
(1, 1, 1, 2)
(1, 1, 1, 3)
(1, 1, 1, 4)
(1, 1, 2, 2)
(1, 1, 2, 3)
(1, 1, 2, 4)
(1, 1, 3, 3)
(1, 1, 3, 4)
(1, 1, 4, 4)
(1, 2, 2, 2)
(1, 2, 2, 3)
(1, 2, 2, 4)
(1, 2, 3, 3)
(1, 2, 3, 4)
(1, 2, 4, 4)
(1, 3, 3, 3)
(1, 3, 3, 4)
(1, 3, 4, 4)
(1, 4, 4, 4)
(2, 2, 2, 2)
(2, 2, 2, 3)
(2, 2, 2, 4)
(2, 2, 3, 3)
(2, 2, 3, 4)
(2, 2, 4, 4)
(2, 3, 3, 3)
(2, 3, 3, 4)
(2, 3, 4, 4)
(2, 4, 4, 4)
(3, 3, 3, 3)
(3, 3, 3, 4)
(3, 3, 4, 4)
(3, 4, 4, 4)
(4, 4, 4, 4)

