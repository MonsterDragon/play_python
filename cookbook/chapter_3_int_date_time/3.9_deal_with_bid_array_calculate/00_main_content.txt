1、问题：我们需要对大型的数据集比如数组或网格进行计算
2、方法：
使用Numpy库
>>> import numpy as ny
>>> ax = ny.array([1, 2, 3, 4])
>>> ax = ny.array([5, 6, 7, 8])
>>> ay = ny.array([5, 6, 7, 8])
>>> ax * 2
array([10, 12, 14, 16])
>>> ax = ny.array([1, 2, 3, 4])
>>> ax * 2
array([2, 4, 6, 8])
>>> ax + 10
array([11, 12, 13, 14])
>>> ax + ay
array([ 6,  8, 10, 12])
>>> ax * ay
array([ 5, 12, 21, 32])
>>> def f(x):
...     return 3*x**2 - x*x + 7
... 
>>> f(ax)
array([ 9, 15, 25, 39])
Numpy提供了一些通用函数的集合。这些通用函数可以作为math模块中函数的替代
>>> ny.sqrt(ax)
array([1.        , 1.41421356, 1.73205081, 2.        ])
>>> ny.cos(ax)
array([ 0.54030231, -0.41614684, -0.9899925 , -0.65364362])
使用Numpy中的通用函数,其效率比对数组进行迭代然后使用math模块中的函数每次只处理一个元素快上百倍
创建一个10000*10000的二维浮点数组
>>> grid = ny.zeros(shape=(10000, 10000), dtype=float)
>>> grid
array([[0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.],
       ...,
       [0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.],
       [0., 0., 0., ..., 0., 0., 0.]])
>>> grid + 10
array([[10., 10., 10., ..., 10., 10., 10.],
      [10., 10., 10., ..., 10., 10., 10.],
      [10., 10., 10., ..., 10., 10., 10.],
      ...,
      [10., 10., 10., ..., 10., 10., 10.],
      [10., 10., 10., ..., 10., 10., 10.],
      [10., 10., 10., ..., 10., 10., 10.]])
Numpy扩展了Python列表的索引功能
>>> a = ny.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
              [ 9, 10, 11, 12]])
>>> a[1]
array([5, 6, 7, 8])
>>> a[:,1]
array([ 2,  6, 10])
>>> a[1:3, 1:3]
array([[ 6,  7],
       [10, 11]])
>>> a[1:3, 1:3] + 10
array([[16, 17],
       [20, 21]])
>>> a
array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
              [ 9, 10, 11, 12]])
>>> a[1:3, 1:3] += 10
>>> a
array([[ 1,  2,  3,  4],
       [ 5, 16, 17,  8],
       [ 9, 20, 21, 12]])
>>> ny.where(a<10, a, 10)
array([[ 1,  2,  3,  4],
       [ 5, 10, 10,  8],
       [ 9, 10, 10, 10]])
