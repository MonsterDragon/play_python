1、问题：我们需要根据一组语法规则来解析文本，以此执行相应的操作或构建一个抽象语法树来表示输入
2、方法：
BNF:是描述语言的形式化的数学方法
基本原理:从一个符号开始(叫做其实标志,实例中常用s表示),然后给出替换前面符号的规则。BNF语法定义的语言只不过是一个字符串集合,你可以按照下述规则书写,这些规则叫做书写规范
symbol := alternative1 | alternative2
每条规则申明:=左侧的符号必须被右侧的某一个可选项代替。替换项"|"分隔(有时用“::=”替换“:=”，但是意思是一样的)。替换项通常有两个符号和终结符构成。之所以叫做终结符是因为没有针对他们的书写规范，他们是书写过程的终止
BNF语法的两一个变数是把中支付放到引号中，把他们与符号区别开来
BNF中有一个特殊符号“@”，表示符号可以去掉。如果@替换符号，只需要将符号去掉。
因此，一个语法描述的语言就是用书写规则写的字符串的集合。如果一个字符串无法用这些规则写出，那么，该字符串在这个语言中就被禁用
s := '-' FN | FN
FN := DL | DL '.' DL
DL := D | D DL
D := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' 
该语法描述的语言的有效句子都是数字，可能是分数，也可能是负数
要写一个数字，首先以s符号开头
EBNF:扩展BNF通过引入下列操作符解决了BNF难以阅读的问题:
1 ?：意思是操作符左边的符号（或括号中的一组符号）是可选项（可以出现0到1次）
1 *：是指重复0次到多次
1 +：是指可以出现一次以上
S := '-'? D+ ('.' D+)?
D := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' 
提示：EBNF在定义语言方面并不比BNf更强大，只是更方便。凡是用EBNF写的东西都可以转换成BNF的形式

在这个问题中，我们吧重点放在根据特定的预压来解析文本上。对于简单的算术运算表达式(BNF)
expr ::= expr + term | expr - term | term
term ::= term * factor | term / factor | factor
factor ::= (expr) | NUM
(EBNF)
expr ::= term { (+|-) term }*
term ::= factor { (*|/) factor}*
factor ::= (expr) | NUM
一般来说，在解析的过程中我们会尝试将输入的文本同语法做匹配，通过BNF来完成各种替换和扩展
NUM + NUM * NUM
expr
expr ::= term { (+|-) term}*
expr ::= factor { (*|/) factor}* { (+|-) term}*
expr ::= NUM { (*|/) factor}* { (+|-) term}*
expr ::= NUM { (+|-) term}*
expr ::= NUM + term { (+|-) term}*
expr ::= NUM + factor { (*|/) factor}* { (+|-) term}*
expr ::= NUM + NUM { (*|/) factor}* { (+|-) term}*
expr ::= NUM + NUM * factor { (*|/) factor}* { (+|-) term}*
expr ::= NUM + NUM * NUM { (*|/) factor}* { (+|-) term}*
expr ::= NUM + NUM * NUM { (+|-) term}*
expr ::= NUM + NUm * NUM
第一个输入标记是一个NUM，因此替换操作首先会把重点放在匹配这一部分上。一旦匹配上来了，重点就转移到下一个标记+上，如此往复。当发现法无法匹配下一个标记时，右手侧的特定部分{ (*|/) factor}*就会消失。在一个成功的解析过程中，整个右手侧部分会完全根据匹配到的输入标记流来相应的扩展

